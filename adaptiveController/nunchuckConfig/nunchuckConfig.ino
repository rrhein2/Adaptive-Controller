// This file is the control code for the one-handed nunchuck portion of the controller

// TODO - consider adding a "unique ID" using the mac address, device type, and possibly something else to prevent MAC spoofing - probably overkill but why not right?

#define PRESSED LOW

#define ESPNOW_WIFI_IFACE WIFI_IF_STA
#define ESPNOW_PAIRING_PMK = "pmk1234567890123"
#define ESPNOW_PAIRING_LMK = "lmk1234567890123"
#define DEV_TYPE_HUB = 0x01


#include <WiFi.h>
#include <esp_mac.h>
#include <vector>
#include <string>
#include "mbedtls/sha256.h"


struct digitalButton {
  short pinNum;
  bool lastState = HIGH;
  unsigned long stateChangeTime = 0;
  String name;
  char btnIndx = 0;
};

struct analogButton {
  short pinNum;
  int lastState = 0;
  unsigned long stateChangeTime = 0;
  String name;
  char btnIndx = '0';
};

digitalButton BUTTON_UP; 
digitalButton BUTTON_RT; 
digitalButton BUTTON_DN; 
digitalButton BUTTON_LT; 
digitalButton BUTTON_BM; 
digitalButton BUTTON_J5; 
digitalButton D_PAD_UP;
digitalButton D_PAD_DN;
digitalButton D_PAD_LT;
digitalButton D_PAD_RT;
// digitalButton BUTTON_K; 

analogButton ANLG_JOY_X_AXIS; 
analogButton ANLG_JOY_Y_AXIS;
analogButton ANLG_TRG;


/* ========== Begin ESPNOW Network Data Code ==========*/


#define WIFI_CHANNEL 11

enum MsgType : uint8_t {
  MSG_PAIRING = 0x01,
  MSG_PAYLOAD = 0x02
};
enum DevType : uint8_t {
  DEV_HUB = 0x01,
  DEV_PERIPHERAL = 0x02
};

// ESPNOW struct configs
#pragma pack(push, 1)
struct pairingData {
  MsgType type;
  DevType devType;
  uint8_t numBtns;
  uint8_t numAnlgs;
  char lmk[16];
  char secret[16];
  uint8_t channel;
}
#pragma pack(pop)

#pragma pack(push, 1)
struct payload {
  MsgType type;
  uint16_t btnStates;
  uint32_t anlgStates[4];
}
#pragma pack(pop)

std::string macAddress;
const DevType devType = 1;
const uint8_t numBtns = 11;
const uint8_t numAnlgs = 2;
const std::string lmk = "lmk9876543210987";
uint8_t pmk[16];
uint8_t channel = 0;
bool pairingMode = false;

// Helper Functions

// secret is generated by the hub at generation and shared during pairing mode. Salt is hub mac address
void derivePMK(const std::string& secret, const std::string& salt, uint8_t output[16])
{
  std::string combinedSalt = secret + salt;
  uint8_t fullHash[32];
  mbedtls_sha256((const uint8_t*)combinedSalt.c_str(), combinedSalt.length(), fullHash, 0);
  memcpy(output, fullHash, 16);
}

std::vector<payload> recvdMsgs;
std::vector<ESP_NOW_NETWORK_HUB> hubs;

class ESP_NOW_NETWORK_HUB : public ESP_NOW_PEER {
  public:

    ESP_NOW_NETWORK_HUB(const uint8_t *mac_addr, uint8_t channel, wifi_interface_t iface, const uint8_t *lmk = nullptr)
      : ESP_NOW_PEER(mac_addr, ESPNOW_WIFI_CHANNEL, ESPNOW_WIFI_IFACE, lmk) {}
    
    ~ESP_NOW_NETWORK_HUB() {}

    // bool begin()
    // {
    //   if(!add())
    //   {
    //     log_e("Failed to initialize ESP-NOW or register the peer");
    //   }
    // }

    bool send_message(const uint8_t *data)
    {
      if (data == NULL || sizeof(*data) == 0)
      {
        log_e("Payload is NULL or has length 0");
        return false;
      }
      return send(data, sizeof(*data));
    }

    void onRecieve(const uint8_t *mac_addr, const uint8_t *data, size_t len)
    {
      // Make sure packets came in properly - if size is damaged then abort
      if (len < sizeof(MsgHeader))
      {
        log_e("Payload not received properly - size too small for message header");
        return
      }

      // grab the header
      MsgType type = static_cast<MsgType>(data[0]);

      switch(type)
      {
        case MSG_PAIRING:
          if(len != sizeof(pairingData))
          {
            log_e("Pairing data missing - aborting packet");
            return;
          }
          /* ==== Register pairing data ==== */
          // if this is the hub
          if(devType == DEV_TYPE_HUB)
          {
            esp_now_peer_info_t newPeer = {};
            memcpy(newPeer.peer_addr, mac_addr*, 6);
            peer.channel = channel;
            peer.encrypt = true;
            memcpy(peer.lmk, deriveLMK(mac_addr), 16);
            esp_now_add_peer(&peer);
          }
          // if this is a peripheral
          else
          {

          }

          break;
        case MSG_PAYLOAD:
          if(len != sizeof(payload))
          {
            log_e("Payload data missing - aborting packet");
            return;
          }
          /* ==== Update controller state ==== */
          // create temp holder for payload
          payload *tempData = (payload *)malloc(sizeof(payload));
          // verify memory allocation
          if(!tempData)
          {
            log_e("Dropped payload - failed memory allocation");
          }
          // copy payload to allocated memory
          memcpy(tempData, data, sizeof(payload))
          // add payload to queue
          recvdMsg.push_back(tempData)


          break
        default:
          log_e("Unknown packet type received - aborting packet");
          break;
      }
    }

}

void registerNewHub(const esp_now_recv_info_t *info, const uint8_t *data, int len, void *arg)
{
  if(!pairingMode)
  {
    log_e("Not in pairing mode - ignoring unknown sender");
    return;
  }

  if(len < 2)
  {
    log_e("Payload from unknown sender is too short to be pairing request - ignoring");
    return;
  }
  MsgType msgType = static_cast<MsgType>(data[0]);
  DevType devType = static_cast<DevType>(data[1]);
  // Only process new hub if the message type is a pairing request and it is sent by a hub. Otherwise, ignore the message
  if(msgType == MSG_PAIRING && devType == DEV_HUB)
  {
    if(len >= sizeof(pairingData))
    {
      const pairingData* payload = static_cast<pairingData*>(data);
      derivePMK(str(pyaload.secret), macAddress, pmk)
      ESP_NOW_NETWORK_HUB newHub(info->src_addr, ESPNOW_WIFI_CHANNEL, WIFI_IF_STA, (const uint8_t*)lmk.data());
    }
    else
    {
      log_e("Payload of pairing request was invalid - ignoring request");
      return;
    }
  }
  else
  {
    log_e("Message is not a pairing request or is not from a hub - ignoring message");
  }
}

/* ========== End ESPNOW Network Data Code ==========*/


void println(int comPort, String payload)
{
  if(comPort == 0)
  {
    Serial.println(payload);
  }
  else if(comPort == 1)
  {
    Serial1.println(payload);
  }
  else
  {
    Serial.println(payload);
    Serial1.println(payload);
  }
}

void println(int comPort, char payload, bool useAtoI = true)
{
  if(comPort == 0)
  {
    if(useAtoI)
    {
      Serial.println((int)payload - '0');
    }
    else
    {
      Serial.println(payload);
    }
  }
  else if(comPort == 1)
  {
    Serial1.println(payload);
  }
  else
  {
    if(useAtoI)
    {
      Serial.println((int)payload - '0');
    }
    else
    {
      Serial.println(payload);
    }    
    Serial1.println(payload);
  }
}



void analogButtonState(analogButton &button, short debounceTime = 10)
{
  int position = analogRead(button.pinNum);
  unsigned long currTime = millis();
  // Serial.println(position == analogLastState[button]);
  if((position - button.lastState > 100 || position - button.lastState < -100) && (currTime - button.stateChangeTime) > debounceTime)
  {
    button.lastState = position;
    button.stateChangeTime = currTime;
    Serial.print(button.name + ": ");
    Serial.println(position);
    // println(2, button.name + ": " + position);
    // println(2, button.btnIndx);
  }
}

void digitalButtonState(digitalButton &button, short debounceTime = 10)
{
  unsigned long currTime = millis();
  int currState = digitalRead(button.pinNum);
  if(currState != button.lastState && (currTime - button.stateChangeTime) > debounceTime)
  {
    button.lastState = currState;
    button.stateChangeTime = currTime;
    if(currState == PRESSED)
    {
      Serial.println(button.name + " button pressed");
      // Serial1.println(button.name + " button pressed");
      // println(2, button.name + " button pressed");
      // println(2, button.btnIndx);
    }
    else
    {
      Serial.println(button.name + " button released");
      // Serial1.println(button.name + " button released");
      // println(2, button.name + " button released");
      // println(2, button.btnIndx);
    }
  }
}


void setup() {
  Serial.begin(115200);
  // Serial1.begin(9600);

  // Initialize button variables
  BUTTON_UP.pinNum = 5;   BUTTON_UP.name = "UP";                  BUTTON_UP.btnIndx = '1';
  BUTTON_RT.pinNum = 6;   BUTTON_RT.name = "RIGHT";               BUTTON_RT.btnIndx = '2';
  BUTTON_DN.pinNum = 7;   BUTTON_DN.name = "DOWN";                BUTTON_DN.btnIndx = '3';
  BUTTON_LT.pinNum = 8;   BUTTON_LT.name = "LEFT";                BUTTON_LT.btnIndx = '4';
  BUTTON_BM.pinNum = 3;   BUTTON_BM.name = "Bumper";              BUTTON_BM.btnIndx = '5';
  BUTTON_J5.pinNum = 2;   BUTTON_J5.name = "Joystick Click";      BUTTON_J5.btnIndx = '6';
  D_PAD_UP.pinNum = 9;    D_PAD_UP.name = "D-Pad UP";             D_PAD_UP.btnIndx = '7';
  D_PAD_DN.pinNum = 10;   D_PAD_DN.name = "D-Pad Down";           D_PAD_DN.btnIndx = '8';
  D_PAD_LT.pinNum = 20;   D_PAD_LT.name = "D-Pad Left";           D_PAD_LT.btnIndx = '9';
  D_PAD_RT.pinNum = 21;   D_PAD_RT.name = "D-Pad Right";          D_PAD_RT.btnIndx = '10';
  
  ANLG_JOY_X_AXIS.pinNum = 0; ANLG_JOY_X_AXIS.name = "X-Axis";
  ANLG_JOY_Y_AXIS.pinNum = 1; ANLG_JOY_Y_AXIS.name = "Y-Axis";
  // ANLG_TRG.pinNum = 4; ANLG_TRG.name = "Trigger";

  // Initiate button pins with pullup resistor
  pinMode(BUTTON_UP.pinNum, INPUT_PULLUP);
  pinMode(BUTTON_DN.pinNum, INPUT_PULLUP);
  pinMode(BUTTON_LT.pinNum, INPUT_PULLUP);
  pinMode(BUTTON_RT.pinNum, INPUT_PULLUP);
  pinMode(BUTTON_BM.pinNum, INPUT_PULLUP);
  pinMode(BUTTON_J5.pinNum, INPUT_PULLUP);
  pinMode(D_PAD_UP.pinNum, INPUT_PULLUP);
  pinMode(D_PAD_DN.pinNum, INPUT_PULLUP);
  pinMode(D_PAD_LT.pinNum, INPUT_PULLUP);
  pinMode(D_PAD_RT.pinNum, INPUT_PULLUP);

  WiFi.mode(WIFI_MODE_STA);
  macAddress = WiFi.macAddress();

}

void loop() {
  digitalButtonState(BUTTON_UP);
  digitalButtonState(BUTTON_DN);
  digitalButtonState(BUTTON_LT);
  digitalButtonState(BUTTON_RT);
  digitalButtonState(BUTTON_BM);
  digitalButtonState(BUTTON_J5);
  digitalButtonState(D_PAD_UP);
  digitalButtonState(D_PAD_DN);
  digitalButtonState(D_PAD_LT);
  digitalButtonState(D_PAD_RT);



  analogButtonState(ANLG_JOY_X_AXIS);
  analogButtonState(ANLG_JOY_Y_AXIS);
  // analogButtonState(ANLG_TRG);
}
